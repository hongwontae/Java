1. Java 실행 흐름

1-1. 소스 작성

1-2. 컴파일
1. javac은 자바 컴파일러입니다.
2. javac helloworld.java 명령어를 실행합니다.
3. 명령어 이후 helloworld.class 파일이 생깁니다. 
=> 이 파일은 바이트코드이며 직접 실행이 불가능하고 JVM만 이해할 수 있는 중간 코드입니다.

1-3. 실행 단계
1. 클래스 로더가 .class 파일을 JVM으로 로드합니다.
(클래스 로더
1. JVM이 java 프로그램을 실행할 떄 필요한 클래스들을 하나씩 메모리에 불러오는 역할
2. main()이 실행되면 Main.class만 메모리에 로딩, 해당 코드가 실행되면서 다른 클래스를 참조할 떄
그 때 그 클래스가 로드됩니다.)

2. 바이트코드 검증기가 안전한지 확인합니다.
(.class 파일이 안전, 유효한지 확인)
3. JVM 인터프리터 또는 JIT 컴파일러가 바이트코드를 실행합니다.
(JVM 인터프리터는 바이트코드를 한 줄씩 실행, 
JIT는 자주 실행되는 바이트코드를 기계어로 변환해줍니다. 이 덕분에 빠르게 실행이 가능합니다.)
=> 인터프리터는 한 줄씩 읽어서 실행, JIT는 성능을 위해 자주 쓰이는 코드를 머신 코드로 변환합니다.
=> 3이 실행되는 순간부터 직접 OS에서 실행되는게 아니고 JVM 위에서 실행되기에 플랫폼 독립성이 존재합니다.


2. Java 변수의 메모리 구조

2-1. Stack (스택 메모리)
=> 메서드 호출 시마다 프레임이 쌓이고 종료되면 pop 됩니다.
=> 각 스레드마다 독립적으로 존재합니다.
=> 지역변수, 매개변수, 메서드 호출 정보를 저장합니다.
=> 참조형 변수의 참조값만 저장하고 실제 객체는 Heap에 있습니다.

2-2. Heap (힙 메모리)
=> new 키워드로 생성되는 객체들이 저장되는 공간입니다.
=> 모든 스레드가 공유합니다.
=> 즉, 참조 타입의 실제 데이터가 위치합니다.

2-3. Method Area => JDK 8 이후에 Metaspace라는 이름으로 대체
=> 클래스 수준의 정보가 저장되는 공간입니다.
=> 클래스 이름, 메서드 정보, static 변수...
=> 모든 스레드가 공유합니다.

2-4. PC Register
=> 각 스레드가 현재 실행 중인 명령어 주소를 저장합니다.

2-5. Native Method Stack
=> C/C++ 등 JVM 외의 네이티브 메서드 실행을 위한 스택입니다.
